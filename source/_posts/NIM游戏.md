---
title: NIM游戏
top: true
cover: false
toc: true
mathjax: true
date: 2020-09-11 11:33:41
password:
summary: 本文介绍NIM游戏的解法，和使用Grundy Numbers解决这类问题的通解方法。
tags:
- 算法
categories:
- 编程算法
---
> 学习自[斯坦福大学算法测试课程](https://web.stanford.edu/class/cs97si/05-combinatorial-games.pdf)

## 简单游戏

$n$ 个石头放置在一起。两个玩家轮流移走1个或3个石头。移走最后那个石头的玩家获胜，如果两个玩家都玩的很好，找出胜者。

### 动态规划求解（DP）

自底向上求解，当 $n$ 较小时：

|  $n$  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $W/L$ |  L   |  W   |  L   |  W   |  L   |  W   |  L   |  W   |

**猜想：** 如果 $n$ 是奇数，第一个玩家获胜。如果 $n$ 是偶数，第二个玩家获胜。

**证明：** 当 $n=0$ 时，成立。

​            当 $n$ 是奇数时，可以移走一个石头，留给对手偶数个石头。

​            当 $n$ 是偶数时，无论怎么做，留给对手奇数个石头。

## MiniMax Algorithm

给定状态下，决定当前玩家最优移动的递归算法。当前玩家在状态 $S$ 下的最优分数定义为 $f(S)$。从 $S$ 移动一步得到的状态为 $T_1, T_2, \dots, T_m$。$T$ 代表 $f(T_i)$ 最小的状态。那么，$f(s) = -f(T)$ 。即，最小化对手的分数，最大化自己的分数。

**伪代码：** 

* 给定状态 $S$ ，计算 $f(S)$ 

* 如果已经知道 $f(S)$ , 直接返回

* 设置返回值 $x \leftarrow - \infty$

* 对每一个有效的下个状态 $T$:
  
  - 更新返回值 $x \leftarrow max{x, -f(T)}$
  
* 将 $f(S) = x $ 存下来，并且返回 $x$

## NIM游戏或拈游戏

有 $n$ 堆石头，两个玩家轮流选择一堆石头，并且从中移走任意数量石头。拿走最后那个石头的玩家获胜。如果两个玩家都玩的很好，找出胜者。

> 当石头堆的数量很多时，不能使用动态规划，因为状态空间很大。

## 解决方法

* 给定堆的大小 $n_1, n_2, \dots, n_m$

* 第一个玩家获胜的充分必要条件是 $n_1 \oplus n_2 \oplus \cdots \oplus n_m$ 的结果非零。$\oplus$ 是异或运算。

**原因：**  
* 如果异或和为0，那么无论当前玩家怎么做，下个状态的异或和不为0。

* 如果异或和非0，那么可以使它变为0 

## Grundy Numbers

当有多个游戏存在时，两个玩家轮流选择一个游戏进行移动，当不能移动时失败。怎么计算胜者呢？

* 对每个游戏，计算出它的Grundy number
* 第一个玩家获胜的条件是所有的Grundy number的异或和为非零值。
   - 例如，当拈游戏只有一堆时，G数等于那堆石头的数量。

**G数计算方法:**

从 $S$ 移动一步得到的状态为 $T_1, T_2, \dots, T_m$。状态 $S$ 的G数 $g(S)$ 是一个不会在 ${g(T_1), g(T_2), \dots, g(T_m)}$ 中出现的最小非负整数。

* Note：失败状态的G数是0

### Example1

只有一堆石头的拈游戏，$g(0)=0$ ,因为这是个必输的状态。状态1只能到达状态0，因此 $g(1)$ 是不会在 ${g(0)}={0}$ 中出现的最小非负整数，即 $g(1) = 1$ 。同样地，$g(2)=2, g(3) =3$ 。这个游戏的G数是$g(n) =n$。

### Example2

和Example1的区别在于每次只能移走1个或2个石头。

G数表：

|  $n$   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $g(n)$ |  0   |  1   |  2   |  0   |  1   |  2   |  0   |  1   |

对于只有一堆的情况，计算G数可能并不需要。但当有 $n$ 堆时，可以计算每堆的G数，然后计算异或。

## Tips

* 如果状态空间较小，使用内存暂存数据，如计算斐波那契数列时可以保存重复使用的一些数据。
* 否则，通过一些测试数据找出模式，如Example2。
* 努力把博弈论转化成类似于拈游戏。
* 当多个游戏同时进行时，使用G数。